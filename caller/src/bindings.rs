/* automatically generated by rust-bindgen 0.58.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const BLACK: u32 = 0;
pub const BLUE: u32 = 1;
pub const GREEN: u32 = 2;
pub const CYAN: u32 = 3;
pub const RED: u32 = 4;
pub const MAGENTA: u32 = 5;
pub const BROWN: u32 = 6;
pub const LIGHTGREY: u32 = 7;
pub const DARKGREY: u32 = 8;
pub const LIGHTBLUE: u32 = 9;
pub const LIGHTGREEN: u32 = 10;
pub const LIGHTCYAN: u32 = 11;
pub const LIGHTRED: u32 = 12;
pub const LIGHTMAGENTA: u32 = 13;
pub const YELLOW: u32 = 14;
pub const WHITE: u32 = 15;
pub const BLINK: u32 = 128;
pub const R_ACCESS: u32 = 0;
pub const W_ACCESS: u32 = 1;
pub const RW_ACCESS: u32 = 2;
pub const RWE_ACCESS: u32 = 3;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub const verbosity_VERBOSITY_LEVEL_0: verbosity = 0;
pub const verbosity_VERBOSITY_LEVEL_1: verbosity = 1;
pub const verbosity_VERBOSITY_LEVEL_2: verbosity = 2;
pub const verbosity_VERBOSITY_LEVEL_3: verbosity = 3;
pub type verbosity = ::std::os::raw::c_int;
pub const MSGTYPE_Normal: MSGTYPE = 0;
pub const MSGTYPE_Info: MSGTYPE = 1;
pub const MSGTYPE_GreenInfo: MSGTYPE = 2;
pub const MSGTYPE_Title: MSGTYPE = 3;
pub const MSGTYPE_Warning: MSGTYPE = 4;
pub const MSGTYPE_Error: MSGTYPE = 5;
pub const MSGTYPE_Verbosity_1: MSGTYPE = 6;
pub const MSGTYPE_Verbosity_2: MSGTYPE = 7;
pub const MSGTYPE_Verbosity_3: MSGTYPE = 8;
pub const MSGTYPE_GreenInfoNoPopup: MSGTYPE = 9;
pub const MSGTYPE_WarningNoPopup: MSGTYPE = 10;
pub const MSGTYPE_ErrorNoPopup: MSGTYPE = 11;
pub type MSGTYPE = ::std::os::raw::c_int;
extern "C" {
    pub fn InitPBar();
}
extern "C" {
    pub fn lBar(x: ::std::os::raw::c_int, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn DisplayMessage(msgType: ::std::os::raw::c_int, str_: *const wchar_t);
}
extern "C" {
    pub fn logMessage(msgType: ::std::os::raw::c_int, str_: *const ::std::os::raw::c_char, ...);
}
#[doc = " \\struct  bankSector."]
#[doc = " \\brief   This stucture indicates the sectors parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bankSector {
    #[doc = "< Index of the sector."]
    pub index: ::std::os::raw::c_uint,
    #[doc = "< Sector size."]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< Sector starting address."]
    pub address: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_bankSector() {
    assert_eq!(
        ::std::mem::size_of::<bankSector>(),
        12usize,
        concat!("Size of: ", stringify!(bankSector))
    );
    assert_eq!(
        ::std::mem::align_of::<bankSector>(),
        4usize,
        concat!("Alignment of ", stringify!(bankSector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bankSector>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bankSector),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bankSector>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bankSector),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bankSector>())).address as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bankSector),
            "::",
            stringify!(address)
        )
    );
}
#[doc = " \\struct  deviceBank."]
#[doc = " \\brief   This stucture defines the memory sectors for each bank."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct deviceBank {
    #[doc = "< Number of sectors of the considered bank."]
    pub sectorsNumber: ::std::os::raw::c_uint,
    #[doc = "< Sectors specifications #Bank_Sector."]
    pub sectors: *mut bankSector,
}
#[test]
fn bindgen_test_layout_deviceBank() {
    assert_eq!(
        ::std::mem::size_of::<deviceBank>(),
        16usize,
        concat!("Size of: ", stringify!(deviceBank))
    );
    assert_eq!(
        ::std::mem::align_of::<deviceBank>(),
        8usize,
        concat!("Alignment of ", stringify!(deviceBank))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<deviceBank>())).sectorsNumber as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(deviceBank),
            "::",
            stringify!(sectorsNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<deviceBank>())).sectors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(deviceBank),
            "::",
            stringify!(sectors)
        )
    );
}
#[doc = " \\struct  storageStructure."]
#[doc = " \\brief   This stucture describes sotrage characterization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct storageStructure {
    #[doc = "< Number of exsisted banks."]
    pub banksNumber: ::std::os::raw::c_uint,
    #[doc = "< Banks sectors definition #Device_Bank."]
    pub banks: *mut deviceBank,
}
#[test]
fn bindgen_test_layout_storageStructure() {
    assert_eq!(
        ::std::mem::size_of::<storageStructure>(),
        16usize,
        concat!("Size of: ", stringify!(storageStructure))
    );
    assert_eq!(
        ::std::mem::align_of::<storageStructure>(),
        8usize,
        concat!("Alignment of ", stringify!(storageStructure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<storageStructure>())).banksNumber as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(storageStructure),
            "::",
            stringify!(banksNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<storageStructure>())).banks as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(storageStructure),
            "::",
            stringify!(banks)
        )
    );
}
#[doc = " \\struct  bitCoefficient_C."]
#[doc = " \\brief   This stucture indicates the coefficients to access to the adequate option bit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitCoefficient_C {
    #[doc = "< Bit multiplier."]
    pub multiplier: ::std::os::raw::c_uint,
    #[doc = "< Bit offset."]
    pub offset: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_bitCoefficient_C() {
    assert_eq!(
        ::std::mem::size_of::<bitCoefficient_C>(),
        8usize,
        concat!("Size of: ", stringify!(bitCoefficient_C))
    );
    assert_eq!(
        ::std::mem::align_of::<bitCoefficient_C>(),
        4usize,
        concat!("Alignment of ", stringify!(bitCoefficient_C))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitCoefficient_C>())).multiplier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bitCoefficient_C),
            "::",
            stringify!(multiplier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitCoefficient_C>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bitCoefficient_C),
            "::",
            stringify!(offset)
        )
    );
}
#[doc = " \\struct  bitValue_C."]
#[doc = " \\brief   This stucture describes the option Bit value."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bitValue_C {
    #[doc = "< Option bit value."]
    pub value: ::std::os::raw::c_uint,
    #[doc = "< Option bit description."]
    pub description: [::std::os::raw::c_char; 200usize],
}
#[test]
fn bindgen_test_layout_bitValue_C() {
    assert_eq!(
        ::std::mem::size_of::<bitValue_C>(),
        204usize,
        concat!("Size of: ", stringify!(bitValue_C))
    );
    assert_eq!(
        ::std::mem::align_of::<bitValue_C>(),
        4usize,
        concat!("Alignment of ", stringify!(bitValue_C))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitValue_C>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bitValue_C),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bitValue_C>())).description as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bitValue_C),
            "::",
            stringify!(description)
        )
    );
}
#[doc = " \\struct  bit_C."]
#[doc = " \\brief   This stucture will be filled by values which characterize the device's option bytes."]
#[doc = " \\note    See product reference manual for more details."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bit_C {
    #[doc = "< Bit name such as RDP, BOR_LEV, nBOOT0..."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Config description."]
    pub description: [::std::os::raw::c_char; 300usize],
    #[doc = "< Word offset."]
    pub wordOffset: ::std::os::raw::c_uint,
    #[doc = "< Bit offset."]
    pub bitOffset: ::std::os::raw::c_uint,
    #[doc = "< Number of bits build the option."]
    pub bitWidth: ::std::os::raw::c_uint,
    #[doc = "< Access Read/Write."]
    pub access: ::std::os::raw::c_uchar,
    #[doc = "< Number of possible values."]
    pub valuesNbr: ::std::os::raw::c_uint,
    #[doc = "< Bits value, #BitValue_C."]
    pub values: *mut *mut bitValue_C,
    #[doc = "< Bits equation, #BitCoefficient_C."]
    pub equation: bitCoefficient_C,
    pub reference: *mut ::std::os::raw::c_uchar,
    pub bitValue: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_bit_C() {
    assert_eq!(
        ::std::mem::size_of::<bit_C>(),
        384usize,
        concat!("Size of: ", stringify!(bit_C))
    );
    assert_eq!(
        ::std::mem::align_of::<bit_C>(),
        8usize,
        concat!("Alignment of ", stringify!(bit_C))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).wordOffset as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(wordOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).bitOffset as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(bitOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).bitWidth as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(bitWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).access as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).valuesNbr as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(valuesNbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).values as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).equation as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(equation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).reference as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bit_C>())).bitValue as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(bit_C),
            "::",
            stringify!(bitValue)
        )
    );
}
#[doc = " \\struct  category_C"]
#[doc = " \\brief   Get option bytes banks categories descriptions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct category_C {
    #[doc = "< Get category name such as Read Out Protection, BOR Level..."]
    pub name: [::std::os::raw::c_char; 100usize],
    #[doc = "< Get bits number of the considered category."]
    pub bitsNbr: ::std::os::raw::c_uint,
    #[doc = "< Get internal bits descriptions."]
    pub bits: *mut *mut bit_C,
}
#[test]
fn bindgen_test_layout_category_C() {
    assert_eq!(
        ::std::mem::size_of::<category_C>(),
        112usize,
        concat!("Size of: ", stringify!(category_C))
    );
    assert_eq!(
        ::std::mem::align_of::<category_C>(),
        8usize,
        concat!("Alignment of ", stringify!(category_C))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<category_C>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(category_C),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<category_C>())).bitsNbr as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(category_C),
            "::",
            stringify!(bitsNbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<category_C>())).bits as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(category_C),
            "::",
            stringify!(bits)
        )
    );
}
#[doc = " \\struct  bank_C"]
#[doc = " \\brief   Get option bytes banks internal descriptions."]
#[doc = " \\note    STLINK and Bootloader interfaces have different addresses to access to option bytes registres."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bank_C {
    #[doc = "< Bank size."]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< Bank starting address."]
    pub address: ::std::os::raw::c_uint,
    #[doc = "< Bank access Read/Write."]
    pub access: ::std::os::raw::c_uchar,
    #[doc = "< Number of option bytes categories."]
    pub categoriesNbr: ::std::os::raw::c_uint,
    #[doc = "< Get bank categories descriptions #Category_C."]
    pub categories: *mut *mut category_C,
}
#[test]
fn bindgen_test_layout_bank_C() {
    assert_eq!(
        ::std::mem::size_of::<bank_C>(),
        24usize,
        concat!("Size of: ", stringify!(bank_C))
    );
    assert_eq!(
        ::std::mem::align_of::<bank_C>(),
        8usize,
        concat!("Alignment of ", stringify!(bank_C))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bank_C>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_C),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bank_C>())).address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_C),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bank_C>())).access as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_C),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bank_C>())).categoriesNbr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_C),
            "::",
            stringify!(categoriesNbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bank_C>())).categories as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bank_C),
            "::",
            stringify!(categories)
        )
    );
}
#[doc = " \\struct  peripheral_C"]
#[doc = " \\brief   Get peripheral option bytes general informations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct peripheral_C {
    #[doc = "< Peripheral name."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Peripheral description."]
    pub description: [::std::os::raw::c_char; 200usize],
    #[doc = "< Number of existed banks."]
    pub banksNbr: ::std::os::raw::c_uint,
    #[doc = "< Get banks descriptions #Bank_C."]
    pub banks: *mut *mut bank_C,
}
#[test]
fn bindgen_test_layout_peripheral_C() {
    assert_eq!(
        ::std::mem::size_of::<peripheral_C>(),
        248usize,
        concat!("Size of: ", stringify!(peripheral_C))
    );
    assert_eq!(
        ::std::mem::align_of::<peripheral_C>(),
        8usize,
        concat!("Alignment of ", stringify!(peripheral_C))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<peripheral_C>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(peripheral_C),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<peripheral_C>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(peripheral_C),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<peripheral_C>())).banksNbr as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(peripheral_C),
            "::",
            stringify!(banksNbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<peripheral_C>())).banks as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(peripheral_C),
            "::",
            stringify!(banks)
        )
    );
}
#[doc = " no messages ever printed by the library"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_VER_LEVEL_NONE: cubeProgrammerVerbosityLevel =
    0;
#[doc = " warning, error and success messages are printed (default)"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_VER_LEVEL_ONE: cubeProgrammerVerbosityLevel =
    1;
#[doc = " error roots informational messages are printed"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_VER_LEVEL_TWO: cubeProgrammerVerbosityLevel =
    2;
#[doc = " debug and informational messages are printed"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_VER_LEVEL_DEBUG:
    cubeProgrammerVerbosityLevel = 3;
#[doc = " no progress bar is printed in the output of the library"]
pub const cubeProgrammerVerbosityLevel_CUBEPROGRAMMER_NO_PROGRESS_BAR:
    cubeProgrammerVerbosityLevel = 4;
#[doc = " \\enum  cubeProgrammerVerbosityLevel"]
#[doc = " \\brief List of verbosity levels."]
pub type cubeProgrammerVerbosityLevel = ::std::os::raw::c_int;
#[doc = " Success (no error)"]
pub const cubeProgrammerError_CUBEPROGRAMMER_NO_ERROR: cubeProgrammerError = 0;
#[doc = " Device not connected"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NOT_CONNECTED: cubeProgrammerError = -1;
#[doc = " Device not found"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NO_DEVICE: cubeProgrammerError = -2;
#[doc = " Device connection error"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_CONNECTION: cubeProgrammerError = -3;
#[doc = " No such file"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NO_FILE: cubeProgrammerError = -4;
#[doc = " Operation not supported or unimplemented on this interface"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NOT_SUPPORTED: cubeProgrammerError = -5;
#[doc = " Interface not supported or unimplemented on this plateform"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_INTERFACE_NOT_SUPPORTED: cubeProgrammerError =
    -6;
#[doc = " Insufficient memory"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NO_MEM: cubeProgrammerError = -7;
#[doc = " Wrong parameters"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_WRONG_PARAM: cubeProgrammerError = -8;
#[doc = " Memory read failure"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_READ_MEM: cubeProgrammerError = -9;
#[doc = " Memory write failure"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_WRITE_MEM: cubeProgrammerError = -10;
#[doc = " Memory erase failure"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_ERASE_MEM: cubeProgrammerError = -11;
#[doc = " File format not supported for this kind of device"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_UNSUPPORTED_FILE_FORMAT: cubeProgrammerError =
    -12;
#[doc = " Refresh required"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_REFRESH_REQUIRED: cubeProgrammerError = -13;
#[doc = " Refresh required"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_NO_SECURITY: cubeProgrammerError = -14;
#[doc = " Changing frequency problem"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_CHANGE_FREQ: cubeProgrammerError = -15;
#[doc = " RDP Enabled error"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_RDP_ENABLED: cubeProgrammerError = -16;
#[doc = " Other error"]
pub const cubeProgrammerError_CUBEPROGRAMMER_ERROR_OTHER: cubeProgrammerError = -99;
#[doc = " \\enum  cubeProgrammerError"]
#[doc = " \\brief List of errors that can be occured."]
pub type cubeProgrammerError = ::std::os::raw::c_int;
#[doc = "< Even parity bit."]
pub const usartParity_EVEN: usartParity = 0;
#[doc = "< Odd parity bit."]
pub const usartParity_ODD: usartParity = 1;
#[doc = "< No check parity."]
pub const usartParity_NONE: usartParity = 2;
#[doc = " \\enum  usartParity"]
#[doc = " \\brief The parity bit in the data frame of the USART communication tells the receiving device if there is any error in the data bits."]
pub type usartParity = ::std::os::raw::c_int;
#[doc = "< No flow control."]
pub const usartFlowControl_OFF: usartFlowControl = 0;
#[doc = "< Hardware flow control : RTS/CTS."]
pub const usartFlowControl_HARDWARE: usartFlowControl = 1;
#[doc = "< Software flow control : Transmission is started and stopped by sending special characters."]
pub const usartFlowControl_SOFTWARE: usartFlowControl = 2;
#[doc = " \\enum  usartFlowControl"]
#[doc = " \\brief UART Flow Control is a method for devices to communicate with each other over UART without the risk of losing data."]
pub type usartFlowControl = ::std::os::raw::c_int;
#[doc = " \\struct  dfuDeviceInfo"]
#[doc = " \\brief   Get DFU device informations ."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dfuDeviceInfo {
    #[doc = "< USB index."]
    pub usbIndex: [::std::os::raw::c_char; 10usize],
    #[doc = "< Bus number."]
    pub busNumber: ::std::os::raw::c_int,
    #[doc = "< Address number."]
    pub addressNumber: ::std::os::raw::c_int,
    #[doc = "< Product number."]
    pub productId: [::std::os::raw::c_char; 100usize],
    #[doc = "< Serial number."]
    pub serialNumber: [::std::os::raw::c_char; 100usize],
    #[doc = "< DFU version."]
    pub dfuVersion: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_dfuDeviceInfo() {
    assert_eq!(
        ::std::mem::size_of::<dfuDeviceInfo>(),
        224usize,
        concat!("Size of: ", stringify!(dfuDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<dfuDeviceInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(dfuDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dfuDeviceInfo>())).usbIndex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dfuDeviceInfo),
            "::",
            stringify!(usbIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dfuDeviceInfo>())).busNumber as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dfuDeviceInfo),
            "::",
            stringify!(busNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dfuDeviceInfo>())).addressNumber as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dfuDeviceInfo),
            "::",
            stringify!(addressNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dfuDeviceInfo>())).productId as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dfuDeviceInfo),
            "::",
            stringify!(productId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dfuDeviceInfo>())).serialNumber as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(dfuDeviceInfo),
            "::",
            stringify!(serialNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dfuDeviceInfo>())).dfuVersion as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(dfuDeviceInfo),
            "::",
            stringify!(dfuVersion)
        )
    );
}
#[doc = " \\struct  usartConnectParameters"]
#[doc = " \\brief   Specify the USART connect parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct usartConnectParameters {
    #[doc = "< Interface identifier: COM1, COM2, /dev/ttyS0..."]
    pub portName: [::std::os::raw::c_char; 100usize],
    #[doc = "< Speed transmission: 115200, 9600..."]
    pub baudrate: ::std::os::raw::c_uint,
    #[doc = "< Parity bit: value in usartParity."]
    pub parity: usartParity,
    #[doc = "< Data bit: value in {6, 7, 8}."]
    pub dataBits: ::std::os::raw::c_uchar,
    #[doc = "< Stop bit: value in {1, 1.5, 2}."]
    pub stopBits: f32,
    #[doc = "< Flow control: value in usartFlowControl."]
    pub flowControl: usartFlowControl,
    #[doc = "< Set No Init bits: value in {0,1}."]
    pub noinitBits: ::std::os::raw::c_uchar,
    #[doc = "< request a read unprotect: value in {0,1}."]
    pub rdu: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_usartConnectParameters() {
    assert_eq!(
        ::std::mem::size_of::<usartConnectParameters>(),
        124usize,
        concat!("Size of: ", stringify!(usartConnectParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<usartConnectParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(usartConnectParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usartConnectParameters>())).portName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usartConnectParameters),
            "::",
            stringify!(portName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usartConnectParameters>())).baudrate as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(usartConnectParameters),
            "::",
            stringify!(baudrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usartConnectParameters>())).parity as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(usartConnectParameters),
            "::",
            stringify!(parity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usartConnectParameters>())).dataBits as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(usartConnectParameters),
            "::",
            stringify!(dataBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usartConnectParameters>())).stopBits as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(usartConnectParameters),
            "::",
            stringify!(stopBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usartConnectParameters>())).flowControl as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(usartConnectParameters),
            "::",
            stringify!(flowControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<usartConnectParameters>())).noinitBits as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(usartConnectParameters),
            "::",
            stringify!(noinitBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<usartConnectParameters>())).rdu as *const _ as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(usartConnectParameters),
            "::",
            stringify!(rdu)
        )
    );
}
#[doc = " \\struct  dfuConnectParameters"]
#[doc = " \\brief   Specify the USB DFU connect parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dfuConnectParameters {
    pub usb_index: *mut ::std::os::raw::c_char,
    #[doc = "< request a read unprotect: value in {0,1}."]
    pub rdu: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_dfuConnectParameters() {
    assert_eq!(
        ::std::mem::size_of::<dfuConnectParameters>(),
        16usize,
        concat!("Size of: ", stringify!(dfuConnectParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<dfuConnectParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(dfuConnectParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dfuConnectParameters>())).usb_index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dfuConnectParameters),
            "::",
            stringify!(usb_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dfuConnectParameters>())).rdu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dfuConnectParameters),
            "::",
            stringify!(rdu)
        )
    );
}
#[doc = " \\struct  spiConnectParameters"]
#[doc = " \\brief   Specify the SPI connect parameters."]
#[doc = " \\note    Recommended SPI parameters : baudrate=375, crcPol=7, direction=0, cpha=0, cpol=0, crc=0, firstBit=1, frameFormat=0, dataSize=1, mode=1, nss=1, nssPulse=1, delay=1"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spiConnectParameters {
    #[doc = "< Speed transmission 187, 375, 750, 1500, 3000, 6000, 12000 KHz."]
    pub baudrate: u32,
    #[doc = "< crc polynom value."]
    pub crcPol: u16,
    #[doc = "< 2LFullDuplex/2LRxOnly/1LRx/1LTx."]
    pub direction: ::std::os::raw::c_int,
    #[doc = "< 1Edge or 2Edge."]
    pub cpha: ::std::os::raw::c_int,
    #[doc = "< LOW or HIGH."]
    pub cpol: ::std::os::raw::c_int,
    #[doc = "< DISABLE or ENABLE."]
    pub crc: ::std::os::raw::c_int,
    #[doc = "< First bit: LSB or MSB."]
    pub firstBit: ::std::os::raw::c_int,
    #[doc = "< Frame format: Motorola or TI."]
    pub frameFormat: ::std::os::raw::c_int,
    #[doc = "< Size of frame data: 16bit or 8bit ."]
    pub dataSize: ::std::os::raw::c_int,
    #[doc = "< Operating mode: Slave or Master."]
    pub mode: ::std::os::raw::c_int,
    #[doc = "< Selection: Soft or Hard."]
    pub nss: ::std::os::raw::c_int,
    #[doc = "< NSS pulse: No Pulse or Pulse."]
    pub nssPulse: ::std::os::raw::c_int,
    #[doc = "< Delay of few microseconds, No Delay or Delay, at least 4us delay is inserted"]
    pub delay: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_spiConnectParameters() {
    assert_eq!(
        ::std::mem::size_of::<spiConnectParameters>(),
        52usize,
        concat!("Size of: ", stringify!(spiConnectParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<spiConnectParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(spiConnectParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).baudrate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(baudrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).crcPol as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(crcPol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).direction as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).cpha as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(cpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).cpol as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(cpol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).crc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).firstBit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(firstBit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<spiConnectParameters>())).frameFormat as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(frameFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).dataSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).mode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).nss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(nss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).nssPulse as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(nssPulse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spiConnectParameters>())).delay as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(spiConnectParameters),
            "::",
            stringify!(delay)
        )
    );
}
#[doc = " \\struct  canConnectParameters"]
#[doc = " \\brief   Specify the CAN connect parameters."]
#[doc = " \\note    Not all configurations are supported by STM32 Bootloader, such as CAN type is STANDARD and the filter should be always activated."]
#[doc = " \\note    Recommended CAN parameters : br=125000, mode=0, ide=0, rtr=0, fifo=0, fm=0, fs=1, fe=1, fbn=0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct canConnectParameters {
    #[doc = "< Baudrate and speed transmission 125KHz, 250KHz, 500KHz..."]
    pub br: ::std::os::raw::c_int,
    #[doc = "< CAN mode: NORMAL, LOOPBACK...,"]
    pub mode: ::std::os::raw::c_int,
    #[doc = "< CAN type: STANDARD or EXTENDED."]
    pub ide: ::std::os::raw::c_int,
    #[doc = "< Frame format: DATA or REMOTE."]
    pub rtr: ::std::os::raw::c_int,
    #[doc = "< Memory of received messages: FIFO0 or FIFO1."]
    pub fifo: ::std::os::raw::c_int,
    #[doc = "< Filter mode: MASK or LIST."]
    pub fm: ::std::os::raw::c_int,
    #[doc = "< Filter scale: 16 or 32."]
    pub fs: ::std::os::raw::c_int,
    #[doc = "< Filter activation: DISABLE or ENABLE."]
    pub fe: ::std::os::raw::c_int,
    #[doc = "< Filter bank number: 0 to 13."]
    pub fbn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_canConnectParameters() {
    assert_eq!(
        ::std::mem::size_of::<canConnectParameters>(),
        36usize,
        concat!("Size of: ", stringify!(canConnectParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<canConnectParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(canConnectParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).br as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).ide as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(ide)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).rtr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(rtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).fifo as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(fifo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).fm as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(fm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).fs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).fe as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(fe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canConnectParameters>())).fbn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(canConnectParameters),
            "::",
            stringify!(fbn)
        )
    );
}
#[doc = " \\struct  i2cConnectParameters"]
#[doc = " \\brief   Specify the I2C connect parameters."]
#[doc = " \\warning The Bootloader Slave address varies depending on the device (see AN2606)."]
#[doc = " \\note    Not all configurations are supported by STM32 Bootloader, such as address in 7 bits form, analog filter: ENABLE, digital filter: DISABLE."]
#[doc = " \\note    Recommended I2C parameters : add=0x??, br=400, sm=1, am=0, af=1, df=0, dnf=0, rt=0, ft=0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2cConnectParameters {
    #[doc = "< Device address in hex format."]
    pub add: ::std::os::raw::c_int,
    #[doc = "< Baudrate and speed transmission : 100 or 400 KHz."]
    pub br: ::std::os::raw::c_int,
    #[doc = "< Speed Mode: STANDARD or FAST."]
    pub sm: ::std::os::raw::c_int,
    #[doc = "< Address Mode: 7 or 10 bits."]
    pub am: ::std::os::raw::c_int,
    #[doc = "< Analog filter: DISABLE or ENABLE."]
    pub af: ::std::os::raw::c_int,
    #[doc = "< Digital filter: DISABLE or ENABLE."]
    pub df: ::std::os::raw::c_int,
    #[doc = "< Digital noise filter: 0 to 15."]
    pub dnf: ::std::os::raw::c_char,
    #[doc = "< Rise time: 0-1000 for STANDARD speed mode and  0-300 for FAST."]
    pub rt: ::std::os::raw::c_int,
    #[doc = "< Fall time: 0-300 for STANDARD speed mode and  0-300 for FAST."]
    pub ft: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_i2cConnectParameters() {
    assert_eq!(
        ::std::mem::size_of::<i2cConnectParameters>(),
        36usize,
        concat!("Size of: ", stringify!(i2cConnectParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<i2cConnectParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(i2cConnectParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).br as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(br)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).sm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(sm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).am as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(am)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).af as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(af)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).df as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(df)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).dnf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(dnf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).rt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(rt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<i2cConnectParameters>())).ft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i2cConnectParameters),
            "::",
            stringify!(ft)
        )
    );
}
#[doc = "< Apply a reset by the software."]
pub const debugResetMode_SOFTWARE_RESET: debugResetMode = 0;
#[doc = "< Apply a reset by the hardware."]
pub const debugResetMode_HARDWARE_RESET: debugResetMode = 1;
#[doc = "< Apply a reset by the internal core peripheral."]
pub const debugResetMode_CORE_RESET: debugResetMode = 2;
#[doc = " \\enum  debugResetMode"]
#[doc = " \\brief Choose the way to apply a system reset."]
pub type debugResetMode = ::std::os::raw::c_int;
#[doc = "< Connect with normal mode, the target is reset then halted while the type of reset is selected using the [debugResetMode]."]
pub const debugConnectMode_NORMAL_MODE: debugConnectMode = 0;
#[doc = "< Connect with hotplug mode,  this option allows the user to connect to the target without halt or reset."]
pub const debugConnectMode_HOTPLUG_MODE: debugConnectMode = 1;
#[doc = "< Connect with under reset mode, option allows the user to connect to the target using a reset vector catch before executing any instruction."]
pub const debugConnectMode_UNDER_RESET_MODE: debugConnectMode = 2;
#[doc = "< Connect with power down mode."]
pub const debugConnectMode_POWER_DOWN_MODE: debugConnectMode = 3;
#[doc = "< Connect with pre reset mode."]
pub const debugConnectMode_PRE_RESET_MODE: debugConnectMode = 4;
#[doc = " \\enum  debugConnectMode"]
#[doc = " \\brief Choose the appropriate mode for connection."]
pub type debugConnectMode = ::std::os::raw::c_int;
#[doc = "< JTAG debug port."]
pub const debugPort_JTAG: debugPort = 0;
#[doc = "< SWD debug port."]
pub const debugPort_SWD: debugPort = 1;
#[doc = " \\enum  debugPort"]
#[doc = " \\brief Select the debug port interface for connection."]
pub type debugPort = ::std::os::raw::c_int;
#[doc = " \\struct  frequencies"]
#[doc = " \\brief   Get supported frequencies for JTAG and SWD ineterfaces."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frequencies {
    #[doc = "<  JTAG frequency."]
    pub jtagFreq: [::std::os::raw::c_uint; 12usize],
    #[doc = "<  Get JTAG supported frequencies."]
    pub jtagFreqNumber: ::std::os::raw::c_uint,
    #[doc = "<  SWD frequency."]
    pub swdFreq: [::std::os::raw::c_uint; 12usize],
    #[doc = "<  Get SWD supported frequencies."]
    pub swdFreqNumber: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_frequencies() {
    assert_eq!(
        ::std::mem::size_of::<frequencies>(),
        104usize,
        concat!("Size of: ", stringify!(frequencies))
    );
    assert_eq!(
        ::std::mem::align_of::<frequencies>(),
        4usize,
        concat!("Alignment of ", stringify!(frequencies))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frequencies>())).jtagFreq as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frequencies),
            "::",
            stringify!(jtagFreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frequencies>())).jtagFreqNumber as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frequencies),
            "::",
            stringify!(jtagFreqNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frequencies>())).swdFreq as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(frequencies),
            "::",
            stringify!(swdFreq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<frequencies>())).swdFreqNumber as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(frequencies),
            "::",
            stringify!(swdFreqNumber)
        )
    );
}
#[doc = " \\struct  debugConnectParameters"]
#[doc = " \\brief   Get device characterization and specify connection parameters through ST-LINK interface."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debugConnectParameters {
    #[doc = "< Select the type of debug interface #debugPort."]
    pub dbgPort: debugPort,
    #[doc = "< Select one of the debug ports connected."]
    pub index: ::std::os::raw::c_int,
    #[doc = "< ST-LINK serial number."]
    pub serialNumber: [::std::os::raw::c_char; 33usize],
    #[doc = "< Firmware version."]
    pub firmwareVersion: [::std::os::raw::c_char; 20usize],
    #[doc = "< Operate voltage."]
    pub targetVoltage: [::std::os::raw::c_char; 5usize],
    #[doc = "< Number of available access port."]
    pub accessPortNumber: ::std::os::raw::c_int,
    #[doc = "< Select access port controller."]
    pub accessPort: ::std::os::raw::c_int,
    #[doc = "< Select the debug CONNECT mode #debugConnectMode."]
    pub connectionMode: debugConnectMode,
    #[doc = "< Select the debug RESET mode #debugResetMode."]
    pub resetMode: debugResetMode,
    #[doc = "< Check Old ST-LINK firmware version."]
    pub isOldFirmware: ::std::os::raw::c_int,
    #[doc = "< Supported frequencies #frequencies."]
    pub freq: frequencies,
    #[doc = "< Select specific frequency."]
    pub frequency: ::std::os::raw::c_int,
    #[doc = "< Indicates if it's Bridge device or not."]
    pub isBridge: ::std::os::raw::c_int,
    #[doc = "< Select connection type, if it's shared, use ST-LINK Server."]
    pub shared: ::std::os::raw::c_int,
    #[doc = "< board Name"]
    pub board: [::std::os::raw::c_char; 100usize],
}
#[test]
fn bindgen_test_layout_debugConnectParameters() {
    assert_eq!(
        ::std::mem::size_of::<debugConnectParameters>(),
        304usize,
        concat!("Size of: ", stringify!(debugConnectParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<debugConnectParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(debugConnectParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debugConnectParameters>())).dbgPort as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(dbgPort)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debugConnectParameters>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).serialNumber as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(serialNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).firmwareVersion as *const _ as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(firmwareVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).targetVoltage as *const _ as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(targetVoltage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).accessPortNumber as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(accessPortNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).accessPort as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(accessPort)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).connectionMode as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(connectionMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).resetMode as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(resetMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).isOldFirmware as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(isOldFirmware)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debugConnectParameters>())).freq as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<debugConnectParameters>())).frequency as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debugConnectParameters>())).isBridge as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(isBridge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debugConnectParameters>())).shared as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<debugConnectParameters>())).board as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(debugConnectParameters),
            "::",
            stringify!(board)
        )
    );
}
#[doc = "< STLINK used as connection interface."]
pub const targetInterfaceType_STLINK_INTERFACE: targetInterfaceType = 0;
#[doc = "< USART used as connection interface."]
pub const targetInterfaceType_USART_INTERFACE: targetInterfaceType = 1;
#[doc = "< USB DFU used as connection interface."]
pub const targetInterfaceType_USB_INTERFACE: targetInterfaceType = 2;
#[doc = "< SPI used as connection interface."]
pub const targetInterfaceType_SPI_INTERFACE: targetInterfaceType = 3;
#[doc = "< I2C used as connection interface."]
pub const targetInterfaceType_I2C_INTERFACE: targetInterfaceType = 4;
#[doc = "< CAN used as connection interface."]
pub const targetInterfaceType_CAN_INTERFACE: targetInterfaceType = 5;
#[doc = " \\enum  targetInterfaceType"]
#[doc = " \\brief Indicates the supported interfaces."]
pub type targetInterfaceType = ::std::os::raw::c_int;
#[doc = " \\struct  displayCallBacks"]
#[doc = " \\brief   Functions must be implemented to personalize the display of messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct displayCallBacks {
    #[doc = "< Add a progress bar."]
    pub initProgressBar: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = "< Display internal messages according to verbosity level."]
    pub logMessage: ::std::option::Option<
        unsafe extern "C" fn(msgType: ::std::os::raw::c_int, str_: *const wchar_t),
    >,
    #[doc = "< Display the loading of read/write process."]
    pub loadBar: ::std::option::Option<
        unsafe extern "C" fn(x: ::std::os::raw::c_int, n: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout_displayCallBacks() {
    assert_eq!(
        ::std::mem::size_of::<displayCallBacks>(),
        24usize,
        concat!("Size of: ", stringify!(displayCallBacks))
    );
    assert_eq!(
        ::std::mem::align_of::<displayCallBacks>(),
        8usize,
        concat!("Alignment of ", stringify!(displayCallBacks))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<displayCallBacks>())).initProgressBar as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(displayCallBacks),
            "::",
            stringify!(initProgressBar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<displayCallBacks>())).logMessage as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(displayCallBacks),
            "::",
            stringify!(logMessage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<displayCallBacks>())).loadBar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(displayCallBacks),
            "::",
            stringify!(loadBar)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct segmentData_C {
    #[doc = "< Segment start address."]
    pub address: ::std::os::raw::c_int,
    #[doc = "< Memory segment size."]
    pub size: ::std::os::raw::c_int,
    #[doc = "< Memory segment data."]
    pub data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_segmentData_C() {
    assert_eq!(
        ::std::mem::size_of::<segmentData_C>(),
        16usize,
        concat!("Size of: ", stringify!(segmentData_C))
    );
    assert_eq!(
        ::std::mem::align_of::<segmentData_C>(),
        8usize,
        concat!("Alignment of ", stringify!(segmentData_C))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<segmentData_C>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(segmentData_C),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<segmentData_C>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(segmentData_C),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<segmentData_C>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(segmentData_C),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\struct  FileData_C"]
#[doc = " \\brief   Get file required informations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fileData_C {
    #[doc = "< File extension type."]
    pub Type: ::std::os::raw::c_int,
    #[doc = "< Number of required segments."]
    pub segmentsNbr: ::std::os::raw::c_int,
    #[doc = "< Segments description."]
    pub segments: *mut segmentData_C,
}
#[test]
fn bindgen_test_layout_fileData_C() {
    assert_eq!(
        ::std::mem::size_of::<fileData_C>(),
        16usize,
        concat!("Size of: ", stringify!(fileData_C))
    );
    assert_eq!(
        ::std::mem::align_of::<fileData_C>(),
        8usize,
        concat!("Alignment of ", stringify!(fileData_C))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fileData_C>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fileData_C),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fileData_C>())).segmentsNbr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fileData_C),
            "::",
            stringify!(segmentsNbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fileData_C>())).segments as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fileData_C),
            "::",
            stringify!(segments)
        )
    );
}
#[doc = " \\struct  GeneralInf"]
#[doc = " \\brief   Get device general informations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct generalInf {
    #[doc = "< Device ID."]
    pub deviceId: ::std::os::raw::c_ushort,
    #[doc = "< Flash memory size."]
    pub flashSize: ::std::os::raw::c_int,
    #[doc = "< Device MCU or MPU."]
    pub type_: [::std::os::raw::c_char; 4usize],
    #[doc = "< Cortex CPU."]
    pub cpu: [::std::os::raw::c_char; 20usize],
    #[doc = "< Device name."]
    pub name: [::std::os::raw::c_char; 100usize],
    #[doc = "< Device serie."]
    pub series: [::std::os::raw::c_char; 100usize],
    #[doc = "< Take notice."]
    pub description: [::std::os::raw::c_char; 150usize],
    #[doc = "< Revision ID."]
    pub revisionId: [::std::os::raw::c_char; 100usize],
    #[doc = "< Board Rpn."]
    pub board: [::std::os::raw::c_char; 100usize],
}
#[test]
fn bindgen_test_layout_generalInf() {
    assert_eq!(
        ::std::mem::size_of::<generalInf>(),
        584usize,
        concat!("Size of: ", stringify!(generalInf))
    );
    assert_eq!(
        ::std::mem::align_of::<generalInf>(),
        4usize,
        concat!("Alignment of ", stringify!(generalInf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).deviceId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).flashSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(flashSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).cpu as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).series as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(series)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).description as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).revisionId as *const _ as usize },
        382usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(revisionId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<generalInf>())).board as *const _ as usize },
        482usize,
        concat!(
            "Offset of field: ",
            stringify!(generalInf),
            "::",
            stringify!(board)
        )
    );
}
#[doc = " \\struct  deviceSector"]
#[doc = " \\brief   Get device sectors basic informations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct deviceSector {
    #[doc = "< Number of Sectors."]
    pub sectorNum: u32,
    #[doc = "< Sector Size in BYTEs."]
    pub sectorSize: u32,
}
#[test]
fn bindgen_test_layout_deviceSector() {
    assert_eq!(
        ::std::mem::size_of::<deviceSector>(),
        8usize,
        concat!("Size of: ", stringify!(deviceSector))
    );
    assert_eq!(
        ::std::mem::align_of::<deviceSector>(),
        4usize,
        concat!("Alignment of ", stringify!(deviceSector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<deviceSector>())).sectorNum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(deviceSector),
            "::",
            stringify!(sectorNum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<deviceSector>())).sectorSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(deviceSector),
            "::",
            stringify!(sectorSize)
        )
    );
}
#[doc = " \\struct  externalLoader"]
#[doc = " \\brief   Get external Loader parameters to launch the process of programming an external flash memory."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct externalLoader {
    #[doc = "< FlashLoader file path."]
    pub filePath: [::std::os::raw::c_char; 200usize],
    #[doc = "< Device Name and Description."]
    pub deviceName: [::std::os::raw::c_char; 100usize],
    #[doc = "< Device Type: ONCHIP, EXT8BIT, EXT16BIT, ..."]
    pub deviceType: ::std::os::raw::c_int,
    #[doc = "< Default Device Start Address."]
    pub deviceStartAddress: u32,
    #[doc = "< Total Size of Device."]
    pub deviceSize: u32,
    #[doc = "< Programming Page Size."]
    pub pageSize: u32,
    #[doc = "< Type number."]
    pub sectorsTypeNbr: u32,
    #[doc = "< Device sectors."]
    pub sectors: *mut deviceSector,
}
#[test]
fn bindgen_test_layout_externalLoader() {
    assert_eq!(
        ::std::mem::size_of::<externalLoader>(),
        328usize,
        concat!("Size of: ", stringify!(externalLoader))
    );
    assert_eq!(
        ::std::mem::align_of::<externalLoader>(),
        8usize,
        concat!("Alignment of ", stringify!(externalLoader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<externalLoader>())).filePath as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(externalLoader),
            "::",
            stringify!(filePath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<externalLoader>())).deviceName as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(externalLoader),
            "::",
            stringify!(deviceName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<externalLoader>())).deviceType as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(externalLoader),
            "::",
            stringify!(deviceType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<externalLoader>())).deviceStartAddress as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(externalLoader),
            "::",
            stringify!(deviceStartAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<externalLoader>())).deviceSize as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(externalLoader),
            "::",
            stringify!(deviceSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<externalLoader>())).pageSize as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(externalLoader),
            "::",
            stringify!(pageSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<externalLoader>())).sectorsTypeNbr as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(externalLoader),
            "::",
            stringify!(sectorsTypeNbr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<externalLoader>())).sectors as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(externalLoader),
            "::",
            stringify!(sectors)
        )
    );
}
#[doc = " \\struct  externalStorageInfo"]
#[doc = " \\brief   Get external storage informations useful for external Loader."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct externalStorageInfo {
    pub externalLoaderNbr: ::std::os::raw::c_uint,
    pub externalLoader: *mut externalLoader,
}
#[test]
fn bindgen_test_layout_externalStorageInfo() {
    assert_eq!(
        ::std::mem::size_of::<externalStorageInfo>(),
        16usize,
        concat!("Size of: ", stringify!(externalStorageInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<externalStorageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(externalStorageInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<externalStorageInfo>())).externalLoaderNbr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(externalStorageInfo),
            "::",
            stringify!(externalLoaderNbr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<externalStorageInfo>())).externalLoader as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(externalStorageInfo),
            "::",
            stringify!(externalLoader)
        )
    );
}
extern "C" {
    #[doc = " \\brief This routine allows to get ST-LINK conneted probe(s)."]
    #[doc = " \\param stLinkList  : Filled with the connected ST-LINK list and its default configurations."]
    #[doc = " \\param shared      : Enable shared mode allowing connection of two or more instances to the same ST-LINK probe."]
    #[doc = " \\return Number of the ST-LINK probes already exists."]
    #[doc = " \\warning The Share option is useful only with ST-LINK Server."]
    #[doc = " \\note  At the end of usage, #deleteInterfaceList must have been called."]
    pub fn getStLinkList(
        stLinkList: *mut *mut debugConnectParameters,
        shared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start connection to device through SWD or JTAG interfaces."]
    #[doc = " \\param debugParameters : Indicates customized configuration for ST-LINK connection,"]
    #[doc = " It is recommended to check [debugConnectParameters] fields before connection."]
    #[doc = " \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub fn connectStLink(debugParameters: debugConnectParameters) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine used to apply a target reset."]
    #[doc = " \\note  Reset operation is only available with JTAG/SWD debug interface."]
    #[doc = " \\param rstMode : Indicates the reset type Soft/Hard/Core #debugResetMode. \\n"]
    #[doc = " \\return 0 if the reset operation finished successfully, otherwise an error occurred."]
    pub fn reset(rstMode: debugResetMode) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to get connected serial ports."]
    #[doc = " \\param usartList : Receive serial ports list and its default configurations."]
    #[doc = " \\return Number of serial ports already connected."]
    #[doc = " \\note  At the end of usage, #deleteInterfaceList must have been called."]
    pub fn getUsartList(usartList: *mut *mut usartConnectParameters) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start connection to device through USART interface."]
    #[doc = " \\param usartParameters : Indicates customized configuration for USART connection."]
    #[doc = " \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub fn connectUsartBootloader(usartParameters: usartConnectParameters)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to send a single byte through the USART interface."]
    #[doc = " \\param byte : The data to be written"]
    #[doc = " \\return 0 if the sending operation correctly achieved, otherwise an error occurred."]
    pub fn sendByteUart(byte: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to get connected DFU devices."]
    #[doc = " \\param dfuList : Receive DFU devices list and its default configurations."]
    #[doc = " \\param iPID : Indicate the Product ID to be used for DFU interface."]
    #[doc = " \\param iVID : Indicate the Vendor ID to be used for DFU interface."]
    #[doc = " \\return Number of DFU devices already connected."]
    #[doc = " \\note  At the end of usage, #deleteInterfaceList must have been called."]
    pub fn getDfuDeviceList(
        dfuList: *mut *mut dfuDeviceInfo,
        iPID: ::std::os::raw::c_int,
        iVID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start a simple connection through USB DFU interface."]
    #[doc = " \\param usbIndex : Indicates the index of DFU ports already connected."]
    #[doc = " \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub fn connectDfuBootloader(usbIndex: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start connection to device through USB DFU interface."]
    #[doc = " \\param dfuConnectParameters : Indicates the dfu connection parameters"]
    #[doc = " \\return 0 if the connection successfully established, otherwise an error occurred."]
    #[doc = " \\note  It's recommanded to use this routine to disable readout protection when connecting a MCU based device."]
    pub fn connectDfuBootloader2(dfuParameters: dfuConnectParameters) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start connection to device through SPI interface."]
    #[doc = " \\param spiParameters : Indicates customized configuration for  SPI connection"]
    #[doc = " \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub fn connectSpiBootloader(spiParameters: spiConnectParameters) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start connection to device through CAN interface."]
    #[doc = " \\param canParameters : Indicates customized configuration for  CAN connection"]
    #[doc = " \\return 0 if the connection successfully established, otherwise an error occurred."]
    #[doc = " \\warning To have CAN full support, you must have St-Link firmware version at least v3JxMxB2."]
    pub fn connectCanBootloader(canParameters: canConnectParameters) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start connection to device through I2C interface."]
    #[doc = " \\param i2cParameters : Indicates customized configuration for  I2C connection"]
    #[doc = " \\return 0 if the connection successfully established, otherwise an error occurred."]
    pub fn connectI2cBootloader(i2cParameters: i2cConnectParameters) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to choose your custom display."]
    #[doc = " \\param c : Fill the struct to customize the display tool."]
    #[doc = " \\note This function must be called first of all to ensure the display management."]
    pub fn setDisplayCallbacks(c: displayCallBacks);
}
extern "C" {
    #[doc = " \\brief This routine allows to choose the verbosity level for display."]
    #[doc = " \\param level : Indicates the verbosity number 0, 1 or 3."]
    pub fn setVerbosityLevel(level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief This routine allows to check connection status [maintained or lost]."]
    #[doc = " \\return 1 if the device is already connected, otherwise the connection to device is lost."]
    pub fn checkDeviceConnection() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to get general device informations."]
    #[doc = " \\return Structure #GeneralInf in which the informations are stored."]
    pub fn getDeviceGeneralInf() -> *mut generalInf;
}
extern "C" {
    #[doc = " \\brief This routine allows to receive memory data on the used interface with the configration already initialized."]
    #[doc = " \\param address   : The address to start reading from."]
    #[doc = " \\param data      : Pointer to the data buffer."]
    #[doc = " \\param size      : It indicates the size for read data."]
    #[doc = " \\return 0 if the reading operation correctly finished, otherwise an error occurred."]
    #[doc = " \\warning Unlike ST-LINK interface, the Bootloader interface can access only to some specific memory regions."]
    pub fn readMemory(
        address: ::std::os::raw::c_uint,
        data: *mut *mut ::std::os::raw::c_uchar,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to write memory data on the user interface with the configration already initialized."]
    #[doc = " \\param address   : The address to start writing from."]
    #[doc = " \\param data      : Pointer to the data buffer."]
    #[doc = " \\param size      : It indicates the size for write data."]
    #[doc = " \\return 0 if the writing operation correctly finished, otherwise an error occurred."]
    #[doc = " \\warning Unlike ST-LINK interface, the Bootloader interface can access only to some specific memory regions."]
    pub fn writeMemory(
        address: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to download data from a file to the memory."]
    #[doc = " File formats that are supported : hex, bin, srec, tsv, elf, axf, out, stm32, ext"]
    #[doc = " \\param filePath  : Indicates the full path of the considered file."]
    #[doc = " \\param address   : The address to start downloading from."]
    #[doc = " \\param skipErase : In case to win in term time and if we have a blank device, we can skip erasing memory before programming [skipErase=0]."]
    #[doc = " \\param verify    : To add verification step after downloading."]
    #[doc = " \\param binPath   : Path of the binary file."]
    #[doc = " \\return 0 if the downloading operation correctly finished, otherwise an error occurred."]
    pub fn downloadFile(
        filePath: *const wchar_t,
        address: ::std::os::raw::c_uint,
        skipErase: ::std::os::raw::c_uint,
        verify: ::std::os::raw::c_uint,
        binPath: *const wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to run the application."]
    #[doc = " \\param address : The address to start executing from."]
    #[doc = " In most cases, the program will run from the Flash memory starting from 0x08000000."]
    #[doc = " \\return 0 if the execution correctly started, otherwise an error occurred."]
    pub fn execute(address: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to erase the whole Flash memory."]
    #[doc = " \\return 0 if the operation finished successfully, otherwise an error was occurred."]
    #[doc = " \\note Depending on the device, this routine can take a particular period of time."]
    pub fn massErase(sFlashMemName: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to erase specific sectors of the Flash memory."]
    #[doc = " \\param sectors   : Indicates the indexs of the specific sectors to be erased."]
    #[doc = " \\param sectorNbr : The number of chosen sectors."]
    #[doc = " \\return 0 if the operation finished successfully, otherwise an error occurred."]
    #[doc = " \\note Each circuit has a specific number of Flash memory sectors."]
    pub fn sectorErase(
        sectors: *mut ::std::os::raw::c_uint,
        sectorNbr: ::std::os::raw::c_uint,
        sFlashMemName: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to disable the readout protection."]
    #[doc = " If the memory is not protected, a message appears to indicate that the device is not"]
    #[doc = " under Readout protection and the command has no effects."]
    #[doc = " \\return 0 if the disabling correctly accomplished, otherwise an error occurred."]
    #[doc = " \\note Depending on the device used, this routine take a specific time."]
    pub fn readUnprotect() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to know the interface what is in use."]
    #[doc = " \\return The target interface type #targetInterfaceType, otherwise -1."]
    pub fn getTargetInterfaceType() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to drop the current read/write operation."]
    #[doc = " \\return 0 if there is no call for stop operation, otherwise 1."]
    pub fn getCancelPointer() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to open and get data from any supported file extension."]
    #[doc = " \\param filePath : Indicates the full path of the considered file."]
    #[doc = " \\return Pointer to #fileData_C if the file has hex, bin, srec or elf as extension, otherwise a null pointer to indicate that the file type is not supported."]
    pub fn fileOpen(filePath: *const wchar_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " \\brief This routine allows to clean up the handled file data."]
    #[doc = " \\param data"]
    pub fn freeFileData(data: *mut fileData_C);
}
extern "C" {
    #[doc = " \\brief This routine allows to verfiy if the indicated file data is identical to Flash memory content."]
    #[doc = " \\param fileData : Input file name."]
    #[doc = " \\param address  : The address to start verifying from, it's considered only if the file has .bin or .binary as extension."]
    #[doc = " \\return 0 if the file data matching Flash memory content, otherwise an error occurred or the data is mismatched."]
    pub fn verify(
        fileData: *mut fileData_C,
        address: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to save the data file content to another file."]
    #[doc = " \\param fileData  : Input file name."]
    #[doc = " \\param sFileName : Output file name."]
    #[doc = " \\return 0 if the output file was created successfully, otherwise an error occurred."]
    pub fn saveFileToFile(
        fileData: *mut fileData_C,
        sFileName: *const wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to save Flash memory content to file."]
    #[doc = " \\param address   : The address to start saving from."]
    #[doc = " \\param size      : Data size to be saved."]
    #[doc = " \\param sFileName : Indicates the file name."]
    #[doc = " \\return 0 if the data copy was acheived successfully, otherwise an error occurred."]
    #[doc = " \\note The file name must finish with an extension \".hex\", \".bin\" or \".srec\""]
    pub fn saveMemoryToFile(
        address: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        sFileName: *const wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to clean up and disconnect the current connected target."]
    #[doc = " \\note This routine disconnect the target and delete the loaded Flash Loaders."]
    pub fn disconnect();
}
extern "C" {
    #[doc = " \\brief This routine allows to clear the list of each created interface."]
    #[doc = " \\note The list is filled by #getStlinkList, #getDfuDeviceList or #getUsartList."]
    pub fn deleteInterfaceList();
}
extern "C" {
    #[doc = " \\brief This routine allows to enter and make an automatic process for memory management through JTAG/SWD, UART, DFU, SPI, CAN and IC interfaces."]
    #[doc = " \\param filePath      : Indicates the full file path."]
    #[doc = " \\param address       : The address to start downloading from."]
    #[doc = " \\param skipErase     : If we have a blank device, we can skip erasing memory before programming [skipErase=0]."]
    #[doc = " \\param verify        : Add verification step after downloading."]
    #[doc = " \\param isMassErase   : Erase the whole Flash memory."]
    #[doc = " \\param obCommand     : Indicates the option bytes commands to be loaded \"-ob [optionbyte=value] [optionbyte=value]...\""]
    #[doc = " \\param run           : Start the application."]
    #[doc = " \\warning Connection to target must be established before performing automatic mode."]
    pub fn automaticMode(
        filePath: *const wchar_t,
        address: ::std::os::raw::c_uint,
        skipErase: ::std::os::raw::c_uint,
        verify: ::std::os::raw::c_uint,
        isMassErase: ::std::os::raw::c_int,
        obCommand: *mut ::std::os::raw::c_char,
        run: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " \\brief This routine allows to get Flash storage information."]
    #[doc = " \\param deviceStorageStruct   : The data strcurure to load memory sectors information."]
    #[doc = " \\return 0 if the operation was acheived successfully, otherwise an error occurred."]
    pub fn getStorageStructure(
        deviceStorageStruct: *mut *mut storageStructure,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows program the given Option Byte."]
    #[doc = " The option bytes are configured by the end user depending on the application requirements."]
    #[doc = " \\param command : Indicates the command to execute."]
    #[doc = " \\return 0 if the programming Option Byte correctly executed, otherwise an error occurred."]
    #[doc = " \\note The command must written as: -ob [optionbyte=value] [optionbyte=value] ..."]
    #[doc = " \\code"]
    #[doc = " int ob = sendOptionBytesCmd(\"ob rdp=0x0 BOR_LEV=0\");"]
    #[doc = " \\endcode"]
    pub fn sendOptionBytesCmd(command: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to get option bytes values of the connected target."]
    #[doc = " \\return Structure #Peripheral_C in which the option bytes descriptions are stored."]
    pub fn initOptionBytesInterface() -> *mut peripheral_C;
}
extern "C" {
    #[doc = " \\brief This routine allows to specify the location of Flash Loader."]
    #[doc = " \\param path : Indicates the full path of the considered folder."]
    pub fn setLoadersPath(path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief This routine allows to specify the path of the external Loaders to be loaded."]
    #[doc = " \\param path : Indicates the full path of the folder containing external Loaders."]
    #[doc = " \\param externalLoaderInfo : Structure in which the external Loaders informations are stored."]
    pub fn setExternalLoaderPath(
        path: *const ::std::os::raw::c_char,
        externalLoaderInfo: *mut *mut externalLoader,
    );
}
extern "C" {
    #[doc = " \\brief This routine allows to get available external Loaders in th mentioned path."]
    #[doc = " \\param path : Indicates the full path of the external Loader file ready for loading."]
    #[doc = " \\param externalStorageNfo : Structure in which we get storage information."]
    #[doc = " \\return 1 if the External loaders cannot be loaded from the path, otherwise 0."]
    #[doc = " \\warning All external Loader files should have the extension \"stldr\"."]
    pub fn getExternalLoaders(
        path: *const ::std::os::raw::c_char,
        externalStorageNfo: *mut *mut externalStorageInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to unload an external Loaders."]
    #[doc = " \\param path : Indicates the full path of the external Loader file ready for unloading."]
    pub fn removeExternalLoader(path: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief This routine allows to delete all target Flash Loaders."]
    pub fn deleteLoaders();
}
extern "C" {
    #[doc = " \\brief This routine allows to read the device unique identifier."]
    #[doc = " \\param data : Pointer to the data buffer."]
    pub fn getUID64(data: *mut *mut ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to erase the BLE stack firmware."]
    #[doc = " \\return 0 if the operation was acheived successfully, otherwise an error occurred."]
    pub fn firmwareDelete() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to make upgrade of BLE stack firmware or FUS firmware."]
    #[doc = " \\param filePath : Indicates the full path of the firmware to be programmed."]
    #[doc = " \\param address : Start address of download."]
    #[doc = " \\param firstInstall : 1 if it is the first installation, otherwise 0, to ignore the firmware delete operation."]
    #[doc = " \\param startStack : Starts the stack after programming."]
    #[doc = " \\param verify : Verify if the download operation is achieved successfully before starting the upgrade."]
    #[doc = " \\return 0 if the operation was acheived successfully, otherwise an error occurred."]
    pub fn firmwareUpgrade(
        filePath: *const wchar_t,
        address: ::std::os::raw::c_uint,
        firstInstall: ::std::os::raw::c_uint,
        startStack: ::std::os::raw::c_uint,
        verify: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start the programmed Stack."]
    #[doc = " \\return 0 if the Stack was started successfully, otherwise an error occurred."]
    pub fn startWirelessStack() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start the programmed Stack."]
    #[doc = " \\param filePath : Indicates the full path of the key file."]
    #[doc = " \\note This is the public key generated by STM32TrustedPackageCreator when signing the firmware using -sign command."]
    #[doc = " \\return 0 if the update was performed successfully, otherwise an error occurred."]
    pub fn updateAuthKey(filePath: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to lock the authentication key and once locked, it is no longer possible to change it."]
    #[doc = " \\return 0 if the lock step was performed successfully, otherwise an error occurred."]
    pub fn authKeyLock() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to write a customized user key."]
    #[doc = " \\param filePath : Indicates the full path of the key file."]
    #[doc = " \\param keyType  : String indicating the key type to be used \"Simple\", \"Master\", \"Encrypted\"."]
    #[doc = " \\return 0 if the write was performed successfully, otherwise an error occurred."]
    pub fn writeUserKey(
        filePath: *const wchar_t,
        keyType: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to activate the AntiRollBack."]
    #[doc = " \\return 0 if the activation was done successfully, otherwise an error occurred."]
    pub fn antiRollBack() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief This routine allows to start and establish a communication with the FUS operator."]
    #[doc = " \\return 0 if the FUS operator was started successfully, otherwise an error occurred."]
    #[doc = " \\note Availbale only for ST-LINK interfaces."]
    pub fn StartFus() -> ::std::os::raw::c_int;
}
